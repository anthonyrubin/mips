.globl x
.globl main
.globl terminate
.globl bkpt_1
.globl bkpt_2
.globl bkpt_3
.data

x:
.word 0x01234567
.word 0x89abcdef

prompt1:  .asciiz   "Enter first number:"
prompt2:  .asciiz "Enter second number:"
prompt3:  .asciiz   "Enter third number: "
number1:  .asciiz  "	  " #number 1 should be stored here
number2:  .asciiz  "	  " #number 2 should be stored here
number3:  .asciiz  "	  " #number 3 should be stored here

#it is not clear how to store memory in the above memory locations (number1, number2, number3)
.text

main:
        addi $v0, $0, 4
        lui $a0, 0x1000
        syscall                # Prompt the user to enter first number (prompt1)

        addi $v0, $0, 8
        syscall                # Get first null terminated string

bkpt_2: add $t3, $0, $v0       # store first null term string in $a1

        addi $v0, $0, 4
        lui $a0, 0x1000
        addi $a0, $a0, 20
        syscall                # Prompt the user to enter second number (prompt2)

        addi $v0, $0, 8        # Get second null terminated string
        syscall

        add $a2, $0, $v0        #store second integer in register $a2

        addi $v0, $0, 4
        lui $a0, 0x1000
        addi $a0, $a0, 41
        syscall                 #prompt the user to enter third number (prompt3)

        addi $v0, $0, 8         #Get third null terminated string
        syscall

        add $a3, $0, $v0        #store the third integer in register $a3

         addiu $t1, $t1, 44  #ascii vslue of a coma (,)
        addiu $t2, $t2, 7  #the maximum amount of characteres that should be in a string (ex:999,999)

        #loop and remove work to loop through the string and remove any comas
        #I am in the process of getting this loop to work in -bare mode
        #I lack comprehension of how to access the imput strings  and store in specific memory locations(number1, number2, number3)
        #Once I figure that out I will be able to make the loop run as it should.

        loop:
	      #la $a1,number1
        add $a1,$a1,$t0   # $a1 = $t0 at specific index.
        lb $a0,($a1)	  # loads first byte from a1
        lui $v0,11	#prints first byte
        add $t0, $t0, 1   #adds 1 to counter $t0
        beq $a0, $t1, removeComa   # if the value at the byte stored in $a0 is equal to the ascii vslue stored in t1, go to removeComa
        #bge  $t0, 8, end
        beq $a0, $zero, terminate
        syscall
        j loop
	      removeComa:

        add $a1, $a1, 1  #adds an extra one to our counter $t0
        add $s7, $zero, 0

        slt     $t0, $v0, 100
        bne     $t0, $zero, loop




terminate:	add $0, $0, $0         # Program terminated
